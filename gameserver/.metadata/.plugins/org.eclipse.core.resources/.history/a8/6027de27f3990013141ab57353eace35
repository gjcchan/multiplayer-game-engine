package dependencies;

import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import AbstractObjects.Entities;

public class QuadTree {

	private final static int  maxObjects = 10;
	private final static int maxDepth = 5;
	
	private final static int TOPLEFT = 0;
	private final static int TOPRIGHT = 1;
	private final static int BOTTOMRIGHT = 2;
	private final static int BOTTOMLEFT = 3;
	
	private int level;
	private List<Entities> objects;
	
	//bounds
	private int originX;
	private int originY;
	private int dimension;
	 
	//nodes
	private QuadTree topLeft;
	private QuadTree topRight;
	private QuadTree bottomLeft;
	private QuadTree bottomRight;

	//constructor
	public QuadTree(int pLevel,int newX,int newY,int newDimension) 
	{
		level = pLevel;
		objects = new ArrayList();
		originX = newX;
		originY = newY;
		dimension = newDimension;
	}
	
	private void split()
	{
		int di = dimension>>1;
		topLeft = new QuadTree(level+1, originX, originY, dimension);
		topRight = new QuadTree(level+1, originX+di, originY,dimension);
		bottomLeft = new QuadTree(level+1, originX, originY+di, dimension);
		bottomRight = new QuadTree(level+1, originX+di, originY+di, dimension);	
	}
	private void refactor()
	{
		for(Entities object: objects)
		{
			int quadrant = getQuadrant(object);
			if(quadrant != -1)
			{
				switch(quadrant)
				{
					case TOPLEFT:
						topLeft.insert(object);
						break;
					case TOPRIGHT:
						topRight.insert(object);
						objects.remove(object);
						break;
					case BOTTOMRIGHT:
						bottomRight.insert(object);
						break;
					case BOTTOMLEFT:
						bottomLeft.insert(object);
						break;
				}
				objects.remove(object);
			}		
		}
	}
	private void insert(Entities object)
	{
		int quadrant = getQuadrant(object);
		if(topLeft != null)
		{
			if(quadrant != -1)
			{
				switch(quadrant)
				{
					case TOPLEFT:
						topLeft.insert(object);
						break;
					case TOPRIGHT:
						topRight.insert(object);
						break;
					case BOTTOMRIGHT:
						bottomRight.insert(object);
						break;
					case BOTTOMLEFT:
						bottomLeft.insert(object);
						break;
				}
				return;
			}
			objects.add(object);
		}
		if(objects.size() > maxObjects && level < maxDepth)
		{
			if(topLeft == null)
			{
				split();
				refactor();
			}
			
		}	
	}
	
	private int getQuadrant(Entities object)
	{
		double midY = originY+dimension>>1;
		double midX = originX+dimension>>1;	
		//check left side (no need to check exceed right side max as previous node would've checked)
		if(object.x < midX && object.x + object.collisionPaddingRight < midX)
		{
			if(object.y < midY && object.y + object.collisionPaddingBottom + object.height < midY)
				return TOPLEFT;
			else if(object.y > midY)
				return BOTTOMLEFT;
		}
		if(object.x > midX)
		{
			if(object.y < midY && object.y + object.collisionPaddingBottom + object.height < midY)
				return TOPRIGHT;
			else if(object.y > midY)
				return BOTTOMRIGHT;
		}
		return -1;
	}
}
