package framework;

import java.io.*;
import java.net.*;
import java.util.*;


//one thread per client uses a lot of memory due to individual stack for client
public class ConnectedSession implements Runnable {
	private Socket connection;
	private InputStream persistentInputStream;
	private BufferedReader streamReader;
	private DataOutputStream persistentOutputStream;
	private int timeout;
	private boolean terminated;
	
	private SessionManager sessionStarter;
	
	private String connectionData;
	
	//basic connection setup
	public ConnectedSession(Socket newConnection)
	{
		connection = newConnection;
		//setup parameters
		/*
		connection.setSoTimeout(timeout);
		connection.setTcpNoDelay(true);
		*/
		terminated = true;
		try {
			persistentInputStream = connection.getInputStream();
			streamReader = new BufferedReader(new InputStreamReader(this.persistentInputStream, "UTF-8"));
			persistentOutputStream = new DataOutputStream(connection.getOutputStream());
			//be sure to use flush()!
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	//more advanced setup have communication with parent
	public ConnectedSession(Socket newConnection, SessionManager initializer)
	{
		sessionStarter = initializer;
		connection = newConnection;
		terminated = true;
		try {
			persistentInputStream = connection.getInputStream();
			streamReader = new BufferedReader(new InputStreamReader(this.persistentInputStream, "UTF-8"));
			persistentOutputStream = new DataOutputStream(connection.getOutputStream());
			//be sure to use flush()!
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
		
	//main listener loop
	public void run()
	{
		terminated = false;
		String newData;
		while(!terminated)
		{
			try {
				newData = streamReader.readLine(); // ONLY TERMINATES BY \n!!! no endline signal it continues reading forever!
				//if client disconnects
				if(newData == null)
				{
					terminated = true;	
				}
				else
				{
					System.out.println(newData);
					this.addToQueue(newData);
				}
			} catch (IOException e) {
				//e.printStackTrace();
				System.out.println(e);
				terminated = true;
				this.dispose();
			}
		}
	}
	
	public void transmit(String data) throws IOException
	{
		persistentOutputStream.writeBytes(data);
		persistentOutputStream.flush();
	}
	public void halt()
	{
		terminated = true;
	}	
	public void dispose()
	{
		halt();
		try {
			connection.close();
			sessionStarter.remove(this);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	//supporting functions
	public String getIP() 
	{
		return connection.getInetAddress().toString().substring(1);		
	}
	public int getPort()
	{
		return connection.getPort();
	}
	private void addToQueue(String data)
	{
		sessionStarter.addToQueue(this.getIP() + " " + data);
	}
	
}
