package corelogic;

import java.io.IOException;
import java.util.Map;

import framework.ConnectionManager;
import framework.RepackagedPlayer;
import framework.sendData;
import gameEntities.Player;
import gameObjects.GameStateObject;

//keeps track of broadcast rate
public class BroadcastTimer implements Runnable{
	//how often to broadcast gamestate per sec
	private static final int broadcastRate = 10;
	private static final int broadcastRateMsec = 100; // 1000 / broadcastRate
	//how often the server expects incoming per sec
	private static final int cmdRate = 10;
	
	//used to compare deltas and determine if a broadcast is needed
	//private GameStateObject previousGameState;
	private GameStateObject gameState;
	
	private sendData repackagedGameState;
	private ConnectionManager UDP;
	
	public BroadcastTimer(GameStateObject passInState, ConnectionManager UDPplug)
	{
		gameState = passInState;
		UDP = UDPplug;
		repackagedGameState = new sendData();
	}
	@Override
	public void run() 
	{
		
		long start;
		long elapsed;
		long wait;
		while(true)
		{
			start = System.nanoTime();
			//do something
			//if(previousGameState != null && !previousGameState.equals(gameState))
			//{
				//previousGameState = gameState;
				repackageGameState();
				broadcastToPlayers();
			//}
			//calcluate how long to sleep
			elapsed = System.nanoTime() - start;
			wait = broadcastRateMsec - elapsed / 1000000;
			try {
				Thread.sleep(wait);
			} catch (InterruptedException e) {
				System.out.println("BROADCAST THREAD: no time to sleep: wait < 0");
			}		
		}
		
	}
	private void repackageGameState()
	{
		repackagedGameState = new sendData();
		for(Map.Entry<String, Player> x : gameState.players.entrySet())
		{	
			RepackagedPlayer temp = new RepackagedPlayer(x.getValue().health, (int)x.getValue().getPosX(), (int)x.getValue().getPosY());
			repackagedGameState.playerList.add(temp);
		}
	}
	private void broadcastToPlayers()
	{
		for(Map.Entry<String, Player> x : gameState.players.entrySet())
		{	
			try {
				UDP.transmitObject(repackagedGameState, x.getKey());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}		
	}
}
