package framework;

import java.io.*;
import java.net.*;
import java.util.*;

import framework.ConnectedSession;


/* could use serversocketchannel from Java.nio.*
 * so it can be nonblocking
 */

public class SessionManager implements Runnable {
	private ServerSocket listener;
	private List<ConnectedSession> connections;
	private boolean terminated;
	
	//used for passing data and commands back to upper level
	private Queue<String> queue;
	
	//basic connection setup
	public SessionManager(int port)
	{
		connections = new ArrayList<ConnectedSession>();
		terminated = true;
		try {
			listener = new ServerSocket(port);
			//allows reuse of same address so OS can reuse socket
			listener.setReuseAddress(true);
			System.out.println("IP Host:" + listener.getInetAddress());
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	//connection setup with commincation with parent
	public SessionManager(int port, Queue<String> passInQueue)
	{
		queue = passInQueue;
		connections = new ArrayList<ConnectedSession>();
		terminated = true;
		try {
			listener = new ServerSocket(port);
			//allows reuse of same address so OS can reuse socket
			listener.setReuseAddress(true);
			System.out.println("IP Host:" + listener.getInetAddress());
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	public void run()
	{
		terminated = false;
		while(!terminated)
		{
			try {
				Socket newConnection = listener.accept();
				//setup parameters
				/*
				newConnection.setSoTimeout(timeout);
				newConnection.setTcpNoDelay(true);
				newConnection.setKeepAlive(false);
				*/
				newConnection.setTcpNoDelay(true); //disable nagle's algorithim for maxiumum streaming performance
				//ConnectedSession placeHolder = new ConnectedSession(newConnection);
				ConnectedSession placeHolder = new ConnectedSession(newConnection, this);
				connections.add(placeHolder);
				System.out.println("connection established to: " + placeHolder.getIP() + ":" + placeHolder.getPort());
				new Thread(placeHolder).start();
			}
			 catch (IOException e) {
					// TODO Auto-generated catch block
					terminated = true;
					e.printStackTrace();
				}
		}
	}	
	// transmit data to client
	public void transmit(String data, String IP)
	{
		//horribly, horribly unoptimized way of finding connection, but it will be place holder for now
		int x = 0;
		while(connections.get(x).getIP() != IP)
		{
			x++;
		}
		try {
			connections.get(x).transmit(data);
		} catch (IOException e) {
			//disconnect from client
			connections.remove(x);
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	//for deleteion of SessionManager
	public void dispose()
	{
		try {
			listener.close();
			for(ConnectedSession x :connections)
			{
				x.dispose();
			}
			connections.removeAll(connections);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	//broadcast message to all clients
	public void broadcast(String data)
	{
		for(ConnectedSession x :connections)
		{
			try {
				x.transmit(data);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}		
	}
	//halting the connection manager for adding new connections without break current connections
	public void haltConnectionManager()
	{
		terminated = true;
	}
	//remove a specific connection ie disconnect and end session
	public void remove(ConnectedSession toBeDeleted)
	{
		toBeDeleted.dispose();
		connections.remove(toBeDeleted);
	}
	//allows sessions to pass recieved data up
	public void addToQueue(String newInput)
	{
		queue.add(newInput);
	}
}
