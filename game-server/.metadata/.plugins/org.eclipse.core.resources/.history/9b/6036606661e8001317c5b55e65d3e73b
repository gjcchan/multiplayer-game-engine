package corelogic;

import java.io.IOException;
import java.util.Map;

import framework.ConnectionManager;
import framework.SessionManager;
import frameworkObjects.RepackagedPlayer;
import frameworkObjects.sendData;
import gameEntities.Player;
import gameObjects.GameStateObject;

//keeps track of broadcast rate
public class BroadcastTimer implements Runnable{
	//how often to broadcast gamestate per sec
	private static final float broadcastRate = 22.222f;
	private static final int broadcastRateMsec =  Math.round(1000 / broadcastRate);
	//how often the server expects incoming per sec
	private static final int cmdRate = 10;
	
	private static final String _TRANSMIT_TYPE = "UDP";
	//used to compare deltas and determine if a broadcast is needed
	//private GameStateObject previousGameState;
	private GameStateObject gameState;
	
	private sendData repackagedGameState;
	private ConnectionManager UDP;
	private SessionManager TCP;
	
	public BroadcastTimer(GameStateObject passInState, ConnectionManager UDPplug)
	{
		gameState = passInState;
		UDP = UDPplug;
		repackagedGameState = new sendData();
	}

	public BroadcastTimer(GameStateObject passInState, ConnectionManager UDPplug, SessionManager TCPplug)
	{
		gameState = passInState;
		UDP = UDPplug;
		TCP = TCPplug;
		repackagedGameState = new sendData();
	}
	public void run() 
	{		
		long start;
		while(true)
		{
			start = System.nanoTime();
			//if(previousGameState != null && !previousGameState.equals(gameState))
			//{
				//previousGameState = gameState;
				repackageGameState();
				broadcastToPlayers();
			//}
			//calcluate how long to sleep
			try {
				Thread.sleep(broadcastRateMsec - (System.nanoTime() - start) / 1000000);
			} catch (InterruptedException e) {
				System.out.println("Something interrupting thread sleep");
			} catch(IllegalArgumentException ex) {
				System.out.print("BROADCAST THREAD: no time to sleep: ");		
				System.out.println("RATE: " + (1000/(Math.abs(broadcastRateMsec - (System.nanoTime() - start) / 1000000) + broadcastRateMsec)) + "TARGET: " + broadcastRate);
			}	
		}
	}
	private void repackageGameState()
	{
		repackagedGameState = new sendData();
		for(Map.Entry<String, Player> x : gameState.players.entrySet())
		{	
			RepackagedPlayer temp = new RepackagedPlayer(
					x.getValue().health, 
					(float)x.getValue().boundingBox.getX(), 
					(float)x.getValue().boundingBox.getY(), 
					x.getValue().index, 
					(float)x.getValue().dx, //used for client-side prediction
					(float)x.getValue().dy);
			repackagedGameState.playerList.add(temp);
		}
	}
	private void broadcastToPlayers()
	{
		//Checks for transmit method of UDP or TCP
		if( _TRANSMIT_TYPE == "UDP")
		{
			for(Map.Entry<String, Player> x : gameState.players.entrySet())
			{	
				try {
					UDP.transmitObject(repackagedGameState, x.getKey(), x.getValue().port);
				} catch (IOException e) {
					e.printStackTrace();
				}
			}		
		} else if( _TRANSMIT_TYPE == "TCP") {
			for(Map.Entry<String, Player> x : gameState.players.entrySet())
			{	
				try {
					TCP.transmitObject(repackagedGameState, x.getKey());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}				
		}
		
	}
}
